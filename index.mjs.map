{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isComplexTypedArray from '@stdlib/array-base-assert-is-complex-typed-array';\nimport isAccessorArray from '@stdlib/array-base-assert-is-accessor-array';\nimport resolveGetter from '@stdlib/array-base-resolve-getter';\nimport reinterpret from '@stdlib/strided-base-reinterpret-complex';\n\n\n// FUNCTIONS //\n\n/**\n* Counts the number of elements in an indexed array that satisfy the provided testing function.\n*\n* @private\n* @param {Collection} x - input array\n* @param {Function} predicate - testing function\n* @param {*} [thisArg] - function context\n* @returns {NonNegativeInteger} number of values for which the provided function evaluates to true\n*\n* @example\n* var x = [ 0, 1, 0, 1 ];\n* function predicate( v ) {\n*     return v > 0;\n* }\n* var n = indexed( x, predicate );\n* // returns 2\n*/\nfunction indexed( x, predicate, thisArg ) {\n\tvar n;\n\tvar i;\n\n\tn = 0;\n\tfor ( i = 0; i < x.length; i++ ) {\n\t\tif ( predicate.call( thisArg, x[ i ], i, x ) ) {\n\t\t\tn += 1;\n\t\t}\n\t}\n\treturn n;\n}\n\n/**\n* Counts the number of elements in an accessor array that satisfy the provided testing function.\n*\n* @private\n* @param {Collection} x - input array\n* @param {Function} predicate - testing function\n* @param {*} [thisArg] - function context\n* @returns {NonNegativeInteger} number of values for which the provided function evaluates to true\n*\n* @example\n* import toAccessorArray from '@stdlib/array-base-to-accessor-array';\n*\n* var x = toAccessorArray( [ 0, 1, 0, 1 ] );\n* function predicate( v ) {\n*\treturn v > 0;\n* }\n* var n = accessors( x, predicate );\n* // returns 2\n*/\nfunction accessors( x, predicate, thisArg ) {\n\tvar get;\n\tvar n;\n\tvar i;\n\n\tget = resolveGetter( x );\n\n\tn = 0;\n\tfor ( i = 0; i < x.length; i++ ) {\n\t\tif ( predicate.call( thisArg, get( x, i ), i, x ) ) {\n\t\t\tn += 1;\n\t\t}\n\t}\n\treturn n;\n}\n\n/**\n* Counts the number of elements in a complex array that satisfy the provided testing function.\n*\n* @private\n* @param {Collection} x - input array\n* @param {Function} predicate - testing function\n* @param {*} [thisArg] - function context\n* @returns {NonNegativeInteger} number of values for which the provided function evaluates to true\n*\n* @example\n* import Complex128Array from '@stdlib/array-complex128';\n*\n* var x = new Complex128Array( [ 1.0, 2.0, 0.0, 0.0, 3.0, 4.0, 0.0, 0.0 ] );\n* function predicate( v ) {\n*\treturn v > 0;\n* }\n* var n = complex( x, predicate );\n* // returns 2\n*/\nfunction complex( x, predicate, thisArg ) {\n\tvar view;\n\tvar n;\n\tvar i;\n\n\tview = reinterpret( x, 0 );\n\n\tn = 0;\n\tfor ( i = 0; i < view.length; i += 2 ) {\n\t\tif ( predicate.call( thisArg, view[ i ], i, view ) || predicate.call( thisArg, view[ i+1 ], i+1, view ) ) {\n\t\t\tn += 1;\n\t\t}\n\t}\n\treturn n;\n}\n\n\n// MAIN //\n\n/**\n* Counts the number of elements in an array that satisfy the provided testing function.\n*\n* @param {Collection} x - input array\n* @param {Function} predicate - testing array\n* @param {*} [thisArg] - function context\n* @returns {NonNegativeInteger} number of truthy values\n*\n* @example\n* var x = [ 0, 1, 0, 1, 1 ];\n* function predicate( v ) {\n*\treturn v > 0;\n* }\n* var n = countIf( x, predicate );\n* // returns 3\n*/\nfunction countIf( x, predicate, thisArg ) {\n\tif ( isAccessorArray( x ) ) {\n\t\tif ( isComplexTypedArray( x ) ) {\n\t\t\treturn complex( x, predicate, thisArg );\n\t\t}\n\t\treturn accessors( x, predicate, thisArg );\n\t}\n\treturn indexed( x, predicate, thisArg );\n}\n\n\n// EXPORTS //\n\nexport default countIf;\n"],"names":["countIf","x","predicate","thisArg","isAccessorArray","isComplexTypedArray","view","n","i","reinterpret","length","call","complex","get","resolveGetter","accessors","indexed"],"mappings":";;gbAqJA,SAASA,EAASC,EAAGC,EAAWC,GAC/B,OAAKC,EAAiBH,GAChBI,EAAqBJ,GArC5B,SAAkBA,EAAGC,EAAWC,GAC/B,IAAIG,EACAC,EACAC,EAKJ,IAHAF,EAAOG,EAAaR,EAAG,GAEvBM,EAAI,EACEC,EAAI,EAAGA,EAAIF,EAAKI,OAAQF,GAAK,GAC7BN,EAAUS,KAAMR,EAASG,EAAME,GAAKA,EAAGF,IAAUJ,EAAUS,KAAMR,EAASG,EAAME,EAAE,GAAKA,EAAE,EAAGF,MAChGC,GAAK,GAGP,OAAOA,CACR,CAwBUK,CAASX,EAAGC,EAAWC,GAzEjC,SAAoBF,EAAGC,EAAWC,GACjC,IAAIU,EACAN,EACAC,EAKJ,IAHAK,EAAMC,EAAeb,GAErBM,EAAI,EACEC,EAAI,EAAGA,EAAIP,EAAES,OAAQF,IACrBN,EAAUS,KAAMR,EAASU,EAAKZ,EAAGO,GAAKA,EAAGP,KAC7CM,GAAK,GAGP,OAAOA,CACR,CA6DSQ,CAAWd,EAAGC,EAAWC,GA3GlC,SAAkBF,EAAGC,EAAWC,GAC/B,IAAII,EACAC,EAGJ,IADAD,EAAI,EACEC,EAAI,EAAGA,EAAIP,EAAES,OAAQF,IACrBN,EAAUS,KAAMR,EAASF,EAAGO,GAAKA,EAAGP,KACxCM,GAAK,GAGP,OAAOA,CACR,CAkGQS,CAASf,EAAGC,EAAWC,EAC/B"}